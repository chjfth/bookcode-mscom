//
// [2020-06-19] Chj applies some improvements to the sample program:
// 1. printf from different threads are serialized.
// 2. User can choose between STA or MTA for the main thread and worker thread.
// 3. If the parameter is a positive number(e.g. 3000), Sum() will executes
//	  for 3000 milliseconds(delay inside). 
// 4. User can try using unmarshaled(=bare) pointer in the worker thread, .
//	  Pass a *negative number* as parameter to activate this.
//
// Memo: For STA, you can see concurrent object calling behavior with this delay behavior.
//
// client.cpp
#define _WIN32_DCOM
#include <windows.h>
#include <stdio.h>
#include <assert.h>
#include <conio.h>

#include <utils.h>

#include "..\registry.h"
#include "Component\component.h" // Generated by MIDL

void PrintSum(ISum *pSum, int a1, int a2)
{
	pl("Client: Calling Sum(%d, %d)...", a1, a2);

	int sum = 0;
	HRESULT hr = pSum->Sum(a1, a2, &sum);

	if(SUCCEEDED(hr)) {
		pl("Client: Sum(%d, %d) returned %d", a1, a2, sum);
	}
	else {
		pl("Client: Sum(%d, %d) failed. HRESULT=0x%X", a1, a2, hr);
	}
}

struct SThreadParam
{
	HANDLE hEventObjReady; // Work thread sets this event, telling main thread COM object ready. 
	HANDLE hEventQuit;  // Main thread sets this event, telling work thread to quit.
	IStream *pStream;   // set by worker, read by main
};

int MyThread(void *param)
{
	DWORD mytid = GetCurrentThreadId();
	pl("Work thread starts running, WorkThread-tid=%d", mytid);

	SThreadParam *ptp = (SThreadParam*)param;
	IStream* pStream = ptp->pStream;

	HRESULT hr = CoInitialize(NULL);
	if(FAILED(hr)) {
		pl("Work thread CoInitialize() failed.");
		return 4;
	}
	else {
		pl("Work thread CoInitialize() success.");
	}

	//
	// Create COM object in worker thread. 
	//

	pl("Client: Work thread calling CoCreateInstance()...");
	ISum* pSum = NULL;
	hr = CoCreateInstance(CLSID_InsideDCOM, NULL, CLSCTX_INPROC_SERVER, IID_ISum, (void**)&pSum);
	if(FAILED(hr)) {
		pl("CoCreateInstance() failed, hr=0x%X", hr);
		return 4;
	}
	else {
		pl("CoCreateInstance() success, the interface-ptr returned is **0x%p**", pSum);
	}

	PrintSum(pSum, 1, 2);

	CoMarshalInterThreadInterfaceInStream(IID_ISum, pSum, &(ptp->pStream));

	SetEvent(ptp->hEventObjReady);

	if(ptp->hEventQuit)
	{
		pl("Work thread: Now wait for quit event...");
		WaitForSingleObject(ptp->hEventQuit, INFINITE);
	}

	pl("Work thread: Calling CoUninitialize() and quit self.");
	CoUninitialize();
	return 0;
}

void MainThreadCallObject(bool is_coinit, IStream *pStream)
{
	HRESULT hr = 0;
	if(is_coinit)
	{
		hr = CoInitialize(NULL);
		if(FAILED(hr)) {
			pl("Main thread CoInitialize() failed, hr=0x%X", hr);
			return;
		}
		else {
			pl("Main thread CoInitialize() success.");
		}
	}

	ISum* pSum = NULL;
	hr = CoGetInterfaceAndReleaseStream(pStream, IID_ISum, (void**)&pSum);
	if(SUCCEEDED(hr))
		pl("Main thread got marsptr: **0x%p**", pSum);
	else {
		pl("Main thread CoGetInterfaceAndReleaseStream() fail! HRESULT=0x%X", hr);
		assert(pSum==NULL);
		return;
	}

	PrintSum(pSum, 20, 30);

	DWORD refcount = pSum->Release();
	pl("Client: Called pSum->Release(). reference count drops to %d", refcount);
}

bool AskForLateCoinit()
{
	printf("For the main thread, do you want to call CoInitialize() *after* the work thread has created COM object? (y/N) ");
	int key = _getch();
	if(key=='y' || key=='Y') {
		printf("AFTER\n");
		return true;
	}
	else {
		printf("BEFORE\n");
		return false;
	}
}

int main(int argc, char *argv[])
{
	HRESULT hr = 0;
	bool is_late_coinit = AskForLateCoinit();

	pl_need_prefix("EXE", true, true, true);

	DWORD mytid = GetCurrentThreadId();
	pl("Client: MainThread-tid=%d", mytid);

	if(!is_late_coinit)
	{
		hr = CoInitialize(NULL);
		if(FAILED(hr)) {
			pl("Main thread CoInitialize() failed, hr=0x%X", hr);
			return 4;
		}
		else {
			pl("Main thread CoInitialize() success.");
		}
	}

	// Print COM objects apartment registry setting. (TODO: require value=null)
	char szregkey[1024] = {0}, szregvalue[1024] = {0}, szClsid[64] = {0};
	CLSIDtochar(CLSID_InsideDCOM, szClsid, sizeof(szClsid));
	_sntprintf_s(szregkey, sizeof(szregkey), _TRUNCATE, "CLSID\\%s\\InprocServer32", szClsid);
	bool succ = HKCR_GetValueSZ(szregkey, "ThreadingModel", szregvalue, sizeof(szregvalue));
	pl("COM object registry-setting ThreadingModel=%s", succ?szregvalue:"(not exist)");

	SThreadParam tp = {};
	tp.hEventObjReady = CreateEvent(NULL, TRUE, FALSE, NULL);
	tp.hEventQuit = CreateEvent(NULL, TRUE, FALSE, NULL);
	HANDLE thread_handle = winCreateThread(MyThread, (void*)&tp);

	// Now the message loop, pump message and wait for thread-done simultaneously.
	BOOL fQuit = FALSE;
	bool isObjReady = false;
	while (!fQuit) 
	{
		DWORD dwResult = MsgWaitForMultipleObjects(1, 
			isObjReady ? &thread_handle : &tp.hEventObjReady, 
			FALSE, // wait either thread-done or MSG appears
			INFINITE, 
			QS_ALLEVENTS);

		switch (dwResult) 
		{{
		case WAIT_OBJECT_0: // The event became signaled.

			if(!isObjReady)
			{
				isObjReady = true;
				MainThreadCallObject(is_late_coinit, tp.pStream);
				SetEvent(tp.hEventQuit);
			}
			else
			{	// worker thread has ended
				fQuit = TRUE;
				break; // break out of `case`
			}

		case WAIT_OBJECT_0 + 1: // A message is in our queue.
			// Dispatch all of the messages.
			MSG msg;
			while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) 
			{
				if (msg.message == WM_QUIT) {
					// A WM_QUIT message, exit the loop
					fQuit = TRUE;
				} else {
					// Translate and dispatch the message.
					TranslateMessage(&msg);
					DispatchMessage(&msg);
				}
			} // Our queue is empty.
			break; // break out of `case`
		}}
	} // End of while loop

	hr = WaitForSingleObject(thread_handle, INFINITE);

	pl("Main thread: Calling CoUninitialize()");
	CoUninitialize();
	return 0;
}
