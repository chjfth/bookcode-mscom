//
// [2020-06-19] Chj applies some improvements to the sample program:
// 1. User can choose between STA or MTA for the created COM object.
// 2. User can try using unmarshaled(=invald) pointer on the worker thread.
// 3. printf from different threads are serialized.
//
// client.cpp
#define _WIN32_DCOM
#include <iostream>  // For cout
using namespace std;
#include <stdio.h>

#include <utils.h>
#include "Component\component.h" // Generated by MIDL

struct SThreadParam
{ 
	IStream *pStream;
	
	ISum *pSumMainThread;
	bool isUseSumBad;
};

DWORD __stdcall MyThread(void *param)
{
	SThreadParam *ptp = (SThreadParam*)param;
	IStream* pStream = ptp->pStream;

	HRESULT hr = CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);
	if(FAILED(hr)) {
		pl("Worker thread CoInitializeEx failed");
		return 4;
	}

	ISum* pSum = NULL;
	CoGetInterfaceAndReleaseStream(pStream, IID_ISum, (void**)&pSum);

	DWORD mytid = GetCurrentThreadId();

	for(int count = 0; count < 10; count++)
	{
		int sum;
		pl("Client: Calling Sum(%d, %d)...", count, count);
		hr = pSum->Sum(count, count, &sum);
		pl("Client: Sum(%d, %d) returns %d", count, count, sum);
	}

	pSum->Release();
	CoUninitialize();
	return 0;
}

int main()
{
	winPrintfLine_need_prefix("EXE-", true, true);
	DWORD mytid = GetCurrentThreadId();
	pl("Client: Calling CoInitialize(). Thread id of MainThread=%d", mytid);

	HRESULT hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
	if(FAILED(hr)) {
		pl("CoInitializeEx failed, hr=0x%X", hr);
		return 4;
	}

	pl("Client: Calling CoCreateInstance()");
	ISum* pSum;
	hr = CoCreateInstance(CLSID_InsideDCOM, NULL, CLSCTX_INPROC_SERVER, IID_ISum, (void**)&pSum);
	if(FAILED(hr)) {
		pl("CoCreateInstance failed, hr=0x%X", hr);
		return 4;
	}

	IStream* pStream;
	CoMarshalInterThreadInterfaceInStream(IID_ISum, pSum, &pStream);

	SThreadParam tp = {};
	tp.pStream =pStream;
	tp.pSumMainThread = pSum;
	DWORD threadid = 0;
	HANDLE thread_handle = CreateThread(0, 0, MyThread, (void*)&tp, 0, &threadid);

	int sum;
	hr = pSum->Sum(2, 3, &sum);
	if(SUCCEEDED(hr)) {
		// cout << "Client: Calling Sum(2, 3) = " << sum << endl;
		pl("Client: Sum(2, 3) returns %d", sum);
	}

	DWORD refcount = pSum->Release();
	pl("Client: Calling pSum->Release(). reference count drops to %d", refcount);

	// Now the message loop, pump message and wait for thread-done simultaneously.
	BOOL fQuit = FALSE;
	while (!fQuit) 
	{
		DWORD dwResult = MsgWaitForMultipleObjects(1, &thread_handle, 
			FALSE, // wait either thread-done or MSG appears
			INFINITE, 
			QS_ALLEVENTS);

		switch (dwResult) 
		{{
		case WAIT_OBJECT_0: // The event became signaled.
			fQuit = TRUE;
			break; // break out of `case`
		case WAIT_OBJECT_0 + 1: // A message is in our queue.
			// Dispatch all of the messages.
			MSG msg;
			while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) 
			{
				if (msg.message == WM_QUIT) {
					// A WM_QUIT message, exit the loop
					fQuit = TRUE;
				} else {
					// Translate and dispatch the message.
					TranslateMessage(&msg);
					DispatchMessage(&msg);
				}
			} // Our queue is empty.
			break; // break out of `case`
		}}
	} // End of while loop

	pl("Client: Calling CoUninitialize()");
	CoUninitialize();
	return 0;
}
