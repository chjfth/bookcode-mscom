//
// [2020-06-19] Chj applies some improvements to the sample program:
// 1. User can choose between STA or MTA for the created COM object.
// 2. User can try using unmarshaled(=invald) pointer on the worker thread, .
//	  Pass "badptr" as parameter to activate this.
// 3. printf from different threads are serialized.
//
// client.cpp
#define _WIN32_DCOM
#include <iostream>  // For cout
using namespace std;
#include <stdio.h>
#include <conio.h>

#include <utils.h>
#include "Component\component.h" // Generated by MIDL

struct SThreadParam
{ 
	IStream *pStream;
	ISum *pSum_bad;
};

int MyThread(void *param)
{
	DWORD mytid = GetCurrentThreadId();
	pl("Worker thread already running, WorkThread-tid=%d", mytid);

	SThreadParam *ptp = (SThreadParam*)param;
	IStream* pStream = ptp->pStream;

	HRESULT hr = CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);
	if(FAILED(hr)) {
		pl("Worker thread CoInitializeEx failed");
		return 4;
	}

	ISum* pSum = NULL;
	if(ptp->pSum_bad==NULL) {
		// The correct way to use cross-thread pointer.
		CoGetInterfaceAndReleaseStream(pStream, IID_ISum, (void**)&pSum);
	}
	else {
		pSum = ptp->pSum_bad;
	}

	for(int count = 0; count < 10; count++)
	{
		int sum;
		pl("Client: Calling Sum(%d, %d)...", count, count);
		hr = pSum->Sum(count, count, &sum);
		pl("Client: Sum(%d, %d) returns %d", count, count, sum);
	}

	pSum->Release();
	CoUninitialize();
	return 0;
}

bool Choose_STA_MTA()
{
	printf("Create COM component as STA or MTA? (1/0) ");
	int key = _getch();
	if(key=='1') {
		printf("STA\n");
		return true;
	}
	else {
		printf("MTA\n");
		return false;
	}
}

int main(int argc, char *argv[])
{
	bool is_try_badptr = false;
	if(argc==2 && strcmp(argv[1], "badptr")==0)
		is_try_badptr = true;

	bool isSTA = Choose_STA_MTA();

	winPrintfLine_need_prefix("EXE-", true, true);

	DWORD mytid = GetCurrentThreadId();
	pl("Client: Calling CoInitialize(). MainThread-tid=%d", mytid);

	HRESULT hr = CoInitializeEx(NULL, isSTA?COINIT_APARTMENTTHREADED:COINIT_MULTITHREADED);
	if(FAILED(hr)) {
		pl("CoInitializeEx failed, hr=0x%X", hr);
		return 4;
	}

	pl("Client: Calling CoCreateInstance()");
	ISum* pSum;
	hr = CoCreateInstance(CLSID_InsideDCOM, NULL, CLSCTX_INPROC_SERVER, IID_ISum, (void**)&pSum);
	if(FAILED(hr)) {
		pl("CoCreateInstance failed, hr=0x%X", hr);
		return 4;
	}

	IStream* pStream;
	CoMarshalInterThreadInterfaceInStream(IID_ISum, pSum, &pStream);

	SThreadParam tp = {};
	tp.pStream = pStream;
	if(is_try_badptr) {
		tp.pSum_bad = pSum;
		pSum->AddRef(); 
	}
	
	HANDLE thread_handle = winCreateThread(MyThread, (void*)&tp);

	int sum;
	hr = pSum->Sum(2, 3, &sum);
	if(SUCCEEDED(hr)) {
		// cout << "Client: Calling Sum(2, 3) = " << sum << endl;
		pl("Client: Sum(2, 3) returns %d", sum);
	}

	DWORD refcount = pSum->Release();
	pl("Client: Calling pSum->Release(). reference count drops to %d", refcount);

	// Now the message loop, pump message and wait for thread-done simultaneously.
	BOOL fQuit = FALSE;
	while (!fQuit) 
	{
		DWORD dwResult = MsgWaitForMultipleObjects(1, &thread_handle, 
			FALSE, // wait either thread-done or MSG appears
			INFINITE, 
			QS_ALLEVENTS);

		switch (dwResult) 
		{{
		case WAIT_OBJECT_0: // The event became signaled.
			fQuit = TRUE;
			break; // break out of `case`
		case WAIT_OBJECT_0 + 1: // A message is in our queue.
			// Dispatch all of the messages.
			MSG msg;
			while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) 
			{
				if (msg.message == WM_QUIT) {
					// A WM_QUIT message, exit the loop
					fQuit = TRUE;
				} else {
					// Translate and dispatch the message.
					TranslateMessage(&msg);
					DispatchMessage(&msg);
				}
			} // Our queue is empty.
			break; // break out of `case`
		}}
	} // End of while loop

	pl("Client: Calling CoUninitialize()");
	CoUninitialize();
	return 0;
}
