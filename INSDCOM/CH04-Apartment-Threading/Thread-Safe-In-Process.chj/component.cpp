// component.cpp
// This in-process component can be installed with the ThreadingModel value
// set to Apartment, Free, or Both. This can be adjusted in the last parameter
// of the RegisterServer function.

#include <iostream>  // For cout
using namespace std;

#include <utils.h>
#include "Component\component.h" // Generated by MIDL
#include "registry.h"  // For registry functions

HINSTANCE g_hInstance;
long g_cComponents = 0;
long g_cServerLocks = 0;

class CInsideDCOM : public ISum
{
public:
	// IUnknown
	ULONG __stdcall AddRef();
	ULONG __stdcall Release();
	HRESULT __stdcall QueryInterface(REFIID riid, void** ppv);

	// ISum
	HRESULT __stdcall Sum(int x, int y, int* retval);
	HRESULT __stdcall SetDelay(int millisec, int* old_delay);

	CInsideDCOM() : m_cRef(1), m_delaymillisec(0) { InterlockedIncrement(&g_cComponents); }
	~CInsideDCOM() { InterlockedDecrement(&g_cComponents); }

private:
	long m_cRef;
	int m_delaymillisec;
};

ULONG CInsideDCOM::AddRef()
{
	pl("Component: CInsideDCOM::AddRef(), m_cRef raise to %d", m_cRef + 1);
	return InterlockedIncrement(&m_cRef);
}

ULONG CInsideDCOM::Release()
{
	pl("Component: CInsideDCOM::Release() m_cRef drops to %d", m_cRef - 1);
	ULONG cRef = InterlockedDecrement(&m_cRef);
	if(cRef != 0)
		return cRef;
	delete this;
	return 0;
}

HRESULT CInsideDCOM::QueryInterface(REFIID riid, void** ppv)
{
	if(riid == IID_IUnknown)
	{
		pl("Component: CInsideDCOM::QueryInterface() for IUnknown returning 0x%p", this);
		*ppv = (IUnknown*)this;
	}
	else if(riid == IID_ISum)
	{
		pl("Component: CInsideDCOM::QueryInterface() for ISum returning 0x%p", this);
		*ppv = (ISum*)this;
	}
	else 
	{
		*ppv = NULL;
		return E_NOINTERFACE;
	}
	AddRef();
	return S_OK;
}

HRESULT CInsideDCOM::Sum(int x, int y, int* retval)
{
	if(m_delaymillisec>0) {
		pl("Component: CInsideDCOM::Sum(%d, %d) start, will cost %d millisec.", x, y, m_delaymillisec);
		Sleep(m_delaymillisec);
	}

	pl("Component: CInsideDCOM::Sum(%d, %d) done on thread-id %d", x, y, GetCurrentThreadId());
	*retval = x + y;
	return S_OK;
}

HRESULT CInsideDCOM::SetDelay(int millisec, int* old_delay)
{
	pl("Component: CInsideDCOM::SetDelay() to %d millisec", millisec);

	if(old_delay)
		*old_delay = m_delaymillisec;
	
	m_delaymillisec = millisec;
	return S_OK;
}

class CFactory : public IClassFactory
{
public:
	// IUnknown
	ULONG __stdcall AddRef();
	ULONG __stdcall Release();
	HRESULT __stdcall QueryInterface(REFIID riid, void** ppv);

	// IClassFactory
	HRESULT __stdcall CreateInstance(IUnknown *pUnknownOuter, REFIID riid, void** ppv);
	HRESULT __stdcall LockServer(BOOL bLock);

	CFactory() : m_cRef(1) { }
	~CFactory() { }

private:
	long m_cRef;
};

ULONG CFactory::AddRef()
{
	pl("Component: CFactory::AddRef(), m_cRef raise to %d", m_cRef + 1);
	return InterlockedIncrement(&m_cRef);
}

ULONG CFactory::Release()
{
	pl("Component: CFactory::Release(), m_cRef drops to %d", m_cRef - 1);
	ULONG cRef = InterlockedDecrement(&m_cRef);
	if(cRef != 0)
		return cRef;
	delete this;
	return 0;
}

HRESULT CFactory::QueryInterface(REFIID riid, void** ppv)
{
	if((riid == IID_IUnknown) || (riid == IID_IClassFactory))
	{
		pl("Component: CFactory::QueryInteface() for IUnknown or IClassFactory 0x%p", this);
		*ppv = (IClassFactory *)this;
	}
	else
	{
		*ppv = NULL;
		return E_NOINTERFACE;
	}
	AddRef();
	return S_OK;
}

HRESULT CFactory::CreateInstance(IUnknown *pUnknownOuter, REFIID riid, void** ppv)
{
	if(pUnknownOuter != NULL)
		return CLASS_E_NOAGGREGATION;

	CInsideDCOM *pInsideDCOM = new CInsideDCOM;
	pl("Component: CFactory::CreateInstance() returning (C++ new) **0x%p**",pInsideDCOM);

	if(pInsideDCOM == NULL)
		return E_OUTOFMEMORY;

	// QueryInterface probably for IID_IUNKNOWN
	HRESULT hr = pInsideDCOM->QueryInterface(riid, ppv);
	pInsideDCOM->Release();
	return hr;
}

HRESULT CFactory::LockServer(BOOL bLock)
{
	if(bLock)
		InterlockedIncrement(&g_cServerLocks);
	else
		InterlockedDecrement(&g_cServerLocks);
	return S_OK;
}

HRESULT __stdcall DllCanUnloadNow()
{
	bool can_unload = g_cServerLocks==0 && g_cComponents==0 ;
	pl("Component: DllCanUnloadNow() %s", (can_unload ? "Yes" : "No"));
	if(can_unload)
		return S_OK;
	else
		return S_FALSE;
}

HRESULT __stdcall DllGetClassObject(REFCLSID clsid, REFIID riid, void** ppv)
{
	pl("Component: DllGetClassObject()");
	
	if(clsid != CLSID_InsideDCOM)
		return CLASS_E_CLASSNOTAVAILABLE;

	CFactory* pFactory = new CFactory;
	if(pFactory == NULL)
		return E_OUTOFMEMORY;

	// QueryInterface probably for IClassFactory
	HRESULT hr = pFactory->QueryInterface(riid, ppv);
	pFactory->Release();
	return hr;
}

HRESULT __stdcall DllRegisterServer()
{
	char DllPath[512];
	OLECHAR wDllPath[512];
	GetModuleFileName(g_hInstance, DllPath, 512);
	mbstowcs(wDllPath, DllPath, 512);
	ITypeLib* pTypeLib;
	HRESULT hr = LoadTypeLibEx(wDllPath, REGKIND_REGISTER, &pTypeLib);
	if(FAILED(hr))
		return hr;
	pTypeLib->Release();

	// Adjust the threading model here
	return RegisterServer("component.dll", CLSID_InsideDCOM, "Inside DCOM Sample", "Component.InsideDCOM", "Component.InsideDCOM.1", "Apartment");
}

HRESULT __stdcall DllUnregisterServer()
{
	HRESULT hr = UnRegisterTypeLib(LIBID_Component, 1, 0, LANG_NEUTRAL, SYS_WIN32);
	if(FAILED(hr))
		return hr;
	return UnregisterServer(CLSID_InsideDCOM, "Component.InsideDCOM", "Component.InsideDCOM.1");
}

BOOL WINAPI DllMain(HINSTANCE hInstDLL, DWORD fdwReason, void* pvReserved)
{
	const char *reason = "";
	switch(fdwReason)
	{
	case DLL_PROCESS_ATTACH:
		g_hInstance = hInstDLL;
		pl_need_prefix("DLL", true, true, true);
		reason = "DLL loaded";
		break;
	case DLL_THREAD_ATTACH:
		reason = "thread created";
		break;
	case DLL_PROCESS_DETACH:
		reason = "DLL unloaded";
		break;
	case DLL_THREAD_DETACH:
		reason ="thread destroyed";
		break;
	}
	
	pl("Inprocess: DllMain() Reason=[%s], called on thread-id %d", reason, GetCurrentThreadId());
	return TRUE;
}
